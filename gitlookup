Logo
Home
Dojos
Achievements
Profile
Pricing
Sign in
dojo
Git Cheatsheet
Start learning for free
ShortcutFoo uses a Spaced Repetition System that adapts to your training.
scf keyboard
Git Basics
git init
Initialize a repository
git status
Show status of working tree
git add file.txt
Start tracking file.txt
git add main.txt
Stage modified file main.txt
git diff
Show what's changed but not yet staged
git commit
Commit changes
git commit -a
Stage files and commit
git mv main.txt file.txt
Rename main.txt to file.txt
git fetch develop
Pull data from remote 'develop' without merging
git pull origin develop
Fetch and merge branch 'develop' from origin
git clone url
Create local copy of remote repository at 'url'
scf keyboard
Branching
git branch
Show current branches
git push origin master
Push master branch to origin server
git branch -v
Show last commit on all branches
git checkout master
Switch to branch 'master'
git branch feature1
Create new branch called 'feature1'
git checkout -b feature2
Create branch 'feature2' and switch to it
git branch -d mybranch
Delete branch 'mybranch'
git branch --merged
Show branches already merged into current branch
git branch --no-merged
Show branches not yet merged into current branch
git branch -D fix
Force delete branch 'fix' that is not yet merged
git push origin feature1
Push local branch 'feature1' to origin
git push staging develop:master
Push develop branch to remote staging master
git checkout -b fix1 origin/fix1
Create local branch 'fix1' based off origin branch
git checkout --track origin/fix2
Create tracking branch 'fix2' based off origin
git push origin :fix2
Delete remote branch 'fix2' from origin
scf keyboard
Merging / Rebasing
git mergetool
Use graphical merge tool
git commit
Finalize merge after resolving conflicts
git merge feature1
Merge branch 'feature1' with current branch
git add file.txt
Mark file.txt as resolved after merge
git rebase develop
Rebase changes made on current branch over develop
git rebase master develop
Rebase master onto develop without checking it out
git rebase --onto master 1a 1b
Rebase master onto branch 1b made from branch 1a
scf keyboard
Remotes
git remote
Show remote servers you have configured
git remote -v
Show remote servers with URL displayed
git remote add myurl url
Add remote server 'url' with shortname 'myurl'
git remote rename server1 server2
Rename remote 'server1' to 'server2'
git remote rm server1
Remove remote 'server1'
git remote show origin
Show info about remote origin
scf keyboard
Commit Logs
git log
Show commit logs
git log -p -2
Show last two commits with diffs
git log --stat
Show commit logs with stats
git log --pretty=oneline
Show commit logs one per line
git log --graph
Show commit logs with ascii graph
git log --since=1.week
Show commit log for the last week
git blame -L 10,15 file.rb
Show prev commits for each lines 10-15 of file.rb
scf keyboard
Undo / Change History
git rm --cached main.txt
Remove main.txt from staging but keep in working
git commit --amend
Replace last commit with whats in staging
git checkout -- file.txt
Discard changes to file.txt
git reset HEAD file.txt
Unstage file.txt
git commit --amend
Modify last commit message
git rebase -i HEAD`3
Make changes to the last 3 commits
scf keyboard
Using Tags
git tag
Show available tags
git tag -a v3.0
Create annotated tag 'v3.0'
git show v3.0
Show info for tag v3.0
git tag -s v3.0
Create signed tag v3.0
git tag v2.1-lw
Create lightweight tag v2.1
git tag -v v3.0
Verify signed tag v3.0
git tag -a v2.2 8feb
Tag previous commit '8feb' as v2.2
git push origin v2.2
Push tag v2.2 to origin
git push origin --tags
Push all local tags to origin
scf keyboard
Using Stashes
git stash
Stash changes without committing
git stash list
Show stores stashes
git stash apply
Reapply most recent stash
git stash apply stash@2
Reapply stash 2
git stash apply --index
Reapply stashed changes along with staged changes
git stash drop stash@{2}
Drop stash 2
git stash pop
Apply most recent stash and drop from stack
git stash branch mybranch
Create branch 'mybranch' from stash
git stash clear
Delete all stashes
git diff --staged
Show what's staged but not yet committed
git diff --check
Check for whitespace errors before committing
scf keyboard
Using Bisect
git bisect start
Start binary search of commits to find bad commit
git bisect bad
Mark current commit as broken during bisect
git bisect good v2.2
Mark v2.2 as last known good commit during bisect
git bisect good
Mark current commit as good during bisect
git bisect reset
Reset HEAD when finished with bisect
git bisect run test.sh
Run 'test.sh' on each commit during bisect
achievement-star
Blog
About
Privacy Policy
Terms of Service
Tournaments
Pricing
Facebook
Twitter
© 2025 ShortcutFoo, LLC. All rights reserved.




// changes 

import React, { useState, useEffect } from "react";
import { SortableItem } from "./sortableitem";

const desktopYLabels = ["4", "6"];
const mobileYLabels = ["2", "3"];
const smartCreativeUsecase = "hubspoke";

// [Unchanged] Static JSON for initial load
const abc = {
  reqId: "Test-0a56ac1c-353c-42b7-a3db-d212edd70e11",
  pageOffset: 0,
  modules: [
    {
      zone: null,
      moduleType: null,
      moduleId: null,
      configs: null,
      moduleResponse: [
        {
          gridId: "dd4c7927-60d4-4377-a582-de87fdeeee",
          status: "pending",
          gridName: "Test 1",
          pageName: "Fashion",
          pageId: "5438",
          updatedts: 1718057641528,
          createdts: 1718057641528,
          usecase: "hubspoke-grid",
          clientInfo: {
            requestBy: "aOsOcI8",
            channel: "Apollo Smart Creative",
          },
          gridOutline: [
            {
              position: 0,
              usecase: "hubspoke-pill",
              groupId: "test-req-sc-hubspoke-7",
              assetId: "de0d50a3-db1a-4654-b32e-123d57670£65",
            },
            {
              position: 1,
              usecase: "hubspoke-pill",
              groupId: "test-req-sc-hubspoke-5",
              assetId: "6c722£13-8d48-45d-b361-39bfb6223eb2",
            },
          ],
          groups: [
            {
              groupId: "test-reg-sc-hubspoke-7",
              status: "generated",
              updatedts: 1734957219756,
              createdts: 1734957219756,
              creativeAltText: {
                content: "Image shows Dyson Supersonic™ Hair Dryer | Fuchsia",
                creativeAiGenerated: false,
                generationInProgress: true,
              },
              type: "creative",
              itemIds: ["5087483962"],
              usecase: "hubspoke-pill",
              clientInfo: {
                requestBy: "kOe042c",
                channel: "scPlugin",
                env: "stage",
              },
              assets: [
                {
                  id: "de0d50a3-db1a-4654-b32e-123d57670£65",
                  modelLabel: "tight",
                  altText: "Image shows Dyson Supersonic™ Hair Dryer | Fuchsia",
                  image: "http://app.stg0.pronto.platform.prod.walmart.com/",
                },
                {
                  id: "a8e253dd-eac5-4cbb-b8fa-07820933b0af",
                  modelLabel: "crop",
                  altText: "Image shows Dyson Supersonic™ Hair Dryer | Fuchsia",
                  image: "http://app.stg0.pronto.platform.prod.walmart.com/",
                },
              ],
            },
            {
              groupId: "test-req-sc-hubspoke-5",
              status: "generated",
              updatedts: 1734956012781,
              createdts: 1734956012781,
              creativeAltText: {
                content: "Image shows Dyson Supersonic™ Hair Dryer | Fuchsia",
                creativeAiGenerated: false,
                generationInProgress: true,
              },
              type: "creative",
              itemIds: ["5087483962"],
              usecase: "hubspoke-pill",
              clientInfo: {
                requestBy: "KOe042c",
                channel: "scPlugin",
                env: "stage",
              },
              assets: [
                {
                  id: "6c722£13-8d48-45fd-b361-39bfb6223eb21",
                  modelLabel: "crop",
                  altText:
                    "Image shows Dyson Supersonic™ Hair Dryer | Fuchsia/Nickel | Refurbished",
                  image: "http://app.stg0.pronto.platform.prod.walmart.com/",
                },
                {
                  id: "bce9befc-c99e-4£71-9150-a6912b3f1a9d",
                  modelLabel: "tight",
                  altText: "Image shows Dyson Supersonic™ Hair Dryer | Fuchsia",
                  image: "http://app.stg0.pronto.platform.prod.walmart.com/",
                },
              ],
            },
          ],
        },
      ],
    },
  ],
  subType: null,
  errorDetails: [],
  features: null,
  styles: null,
};

const HubspokePreview = () => {
  // -------------------------------------------------------------------
  // 1) All states
  // -------------------------------------------------------------------
  const [heading, setHeading] = useState(undefined);
  const [subheading, setSubHeading] = useState(undefined);
  const [showApproveModal, setShowApproveModal] = useState(false);
  const [requestProcessing, setRequestProcessing] = useState(false);
  const [reason, setReason] = useState(undefined);
  const [selectedObj, setSelectedObj] = useState(undefined);
  const [recommendation, setRecommendation] = useState(undefined);
  const [comments, setComments] = useState(undefined);
  const [reasonSelected, setReasonSelected] = useState(undefined);
  const [showRejectModal, setShowRejectModal] = useState(false);
  const [showDeleteModal, setShowDeleteModal] = useState(false);

  // [CHANGED] We keep the "activeTab" toggle, but both will use the same images
  const [activeTab, setActiveTab] = useState("desktop");

  // Each item in groupsState represents a "group" with multiple assets
  const [groupsState, setGroupsState] = useState([]);

  // [ADDED] We'll store JSON for "Add New Item" here. The user can paste 
  // a JSON snippet containing "groups: [...]."
  const [newGroupsJson, setNewGroupsJson] = useState("");

  // Instead of asset-level selection, we treat "selectedAssetId" as the selected group’s ID
  const [selectedAssetId, setSelectedAssetId] = useState(null);

  // Keep track of how many rows (e.g. 4-row or 6-row)
  const [selectedAssembly, setSelectedAssembly] = useState("4");
  const [innerCollapsed, setInnerCollapsed] = useState(true);
  const [modalInput, setModalInput] = useState({
    reason: "",
    details: "",
    recommendations: "",
  });
  const [showModal, setShowModal] = useState({ type: "", assetId: null });
  const [draggedItemId, setDraggedItemId] = useState(null);

  // Data loading
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // Basic metadata (pageName, etc.)
  const [metadata, setMetadata] = useState({
    pageName: "",
    bannerColor: "#FFFFFF",
    creator: "",
    creationDate: "",
    status: "",
    deviceType: "Desktop",
  });

  // Keep the outline so we can update asset IDs
  const [gridOutline, setGridOutline] = useState([]);

  // -------------------------------------------------------------------
  // 2) Hooks
  // -------------------------------------------------------------------
  useEffect(() => {
    try {
      setData(abc);
      setLoading(false);
    } catch (err) {
      setError(err);
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    if (!data) return;

    const moduleResponse = data.modules?.[0]?.moduleResponse?.[0];
    if (!moduleResponse) return;

    setGridOutline(moduleResponse.gridOutline || []);

    const { pageName, status, clientInfo, createdts, groups } = moduleResponse;
    const creationDateStr = createdts
      ? new Date(createdts).toLocaleString()
      : new Date().toLocaleString();

    setMetadata((prev) => ({
      ...prev,
      pageName: pageName || "Untitled Page",
      creator: clientInfo?.requestBy || "Unknown",
      creationDate: creationDateStr,
      status: status || "Draft",
    }));

    // Build groupsState from the groups array
    if (groups && Array.isArray(groups)) {
      const newGroupsState = groups.map((g) => {
        // figure out which asset is selected for this group
        const outlineItem = moduleResponse.gridOutline.find(
          (o) => o.groupId === g.groupId
        );
        const selectedAssetId = outlineItem?.assetId || g.assets?.[0]?.id;
        return {
          groupId: g.groupId,
          allAssets: g.assets || [],
          selectedAssetId,
        };
      });
      setGroupsState(newGroupsState);
    }
  }, [data]);

  useEffect(() => {
    // update assembly anytime groups or the activeTab changes
    updateAssembly();
  }, [activeTab, groupsState]);

  useEffect(() => {
    // For mobile, collapse if needed
    if (activeTab === "mobile") {
      const maxItemsPerRow = parseInt(selectedAssembly, 10);
      const groupChunks = chunkArray(groupsState, maxItemsPerRow);
      setInnerCollapsed(groupChunks.length > 2);
    } else {
      setInnerCollapsed(false);
    }
  }, [activeTab, selectedAssembly, groupsState]);

  // -------------------------------------------------------------------
  // 3) Conditional Returns
  // -------------------------------------------------------------------
  if (loading) return <div>Loading data...</div>;
  if (error) return <div>Error loading data: {error.message}</div>;
  if (!data) return <div>No data available</div>;

  const moduleResponse = data.modules?.[0]?.moduleResponse?.[0];
  if (!moduleResponse) {
    return <div>No moduleResponse found in data</div>;
  }

  // -------------------------------------------------------------------
  // 4) Helper Functions
  // -------------------------------------------------------------------
  function updateAssembly() {
    const count = groupsState.length;
    if (activeTab === "desktop") {
      setSelectedAssembly(count > 4 ? "6" : "4");
    } else {
      setSelectedAssembly(count <= 4 ? "2" : "3");
    }
  }

  function chunkArray(array, size) {
    const result = [];
    for (let i = 0; i < array.length; i += size) {
      result.push(array.slice(i, i + size));
    }
    return result;
  }

  // When user picks a new modelLabel in the dropdown
  const handleModelLabelChange = (groupId, newModelLabel) => {
    setGroupsState((prev) =>
      prev.map((g) => {
        if (g.groupId === groupId) {
          const foundAsset = g.allAssets.find(
            (a) => a.modelLabel === newModelLabel
          );
          if (foundAsset) {
            setGridOutline((prevOutline) =>
              prevOutline.map((o) => {
                if (o.groupId === groupId) {
                  return { ...o, assetId: foundAsset.id };
                }
                return o;
              })
            );
            return { ...g, selectedAssetId: foundAsset.id };
          }
        }
        return g;
      })
    );
  };

  // We only have one set of images (desktop), so use the same images in both tabs
  function getImageSize(assemblyLabel, screenSize) {
    const maxItemsPerRow = parseInt(assemblyLabel, 10);

    // If activeTab is desktop, we do logic for 1280 vs Inh
    // If activeTab is mobile, we do logic for 375
    // But in both cases, we display the same finalAsset.image
    if (activeTab === "desktop") {
      if (screenSize === "1280") {
        if (maxItemsPerRow === 4) return 290;
        if (maxItemsPerRow === 6) return 192;
      } else if (screenSize === "Inh") {
        if (maxItemsPerRow === 4) return 200;
        if (maxItemsPerRow === 6) return 132;
      }
    } else {
      // Mobile
      if (screenSize === "375") {
        if (maxItemsPerRow === 2) return 135;
        if (maxItemsPerRow === 3) return 104;
      }
    }
    return 100;
  }

  // [ADDED] “Add new item” accepts a JSON with { groups: [...] } 
  // and appends them to groupsState
  const handleAddNewItem = () => {
    if (!newGroupsJson.trim()) {
      alert("Please paste valid JSON with a 'groups' array.");
      return;
    }
    try {
      // Example: user pastes 
      // {
      //   "groups": [
      //      { "groupId": "...", "assets": [...] },
      //      ...
      //   ]
      // }
      const parsed = JSON.parse(newGroupsJson);
      const newGroups = parsed.groups || [];

      // Map each new group into our standard shape
      const appendedItems = newGroups.map((g) => {
        // No gridOutline for them yet, so we pick the first asset’s ID as default
        const defaultId = g.assets?.[0]?.id;
        return {
          groupId: g.groupId,
          allAssets: g.assets || [],
          selectedAssetId: defaultId,
        };
      });

      // Append them
      setGroupsState((prev) => [...prev, ...appendedItems]);

      // Clear the input
      setNewGroupsJson("");
      alert(`Appended ${newGroups.length} new groups to the ordering.`);
    } catch (err) {
      alert("Invalid JSON. Please ensure it's valid and includes 'groups'.");
      console.error(err);
    }
  };

  // Drag & Drop
  const handleDragStart = (e, groupId) => {
    setDraggedItemId(groupId);
    e.dataTransfer.effectAllowed = "move";
  };

  const handleDragOver = (e) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = "move";
  };

  const handleDrop = (e, groupId) => {
    e.preventDefault();
    const draggedIndex = groupsState.findIndex((g) => g.groupId === draggedItemId);
    const dropIndex = groupsState.findIndex((g) => g.groupId === groupId);
    if (draggedIndex !== dropIndex) {
      const updated = [...groupsState];
      const [draggedGroup] = updated.splice(draggedIndex, 1);
      updated.splice(dropIndex, 0, draggedGroup);
      setGroupsState(updated);
    }
    setDraggedItemId(null);
  };

  const handleSelectAsset = (groupId) => {
    setSelectedAssetId(groupId === selectedAssetId ? null : groupId);
  };

  // Basic action logic
  const handleAction = (actionType) => {
    if (!selectedAssetId) {
      alert("No group selected.");
      return;
    }
    const selectedGroup = groupsState.find((g) => g.groupId === selectedAssetId);
    if (!selectedGroup) return;

    if (actionType === "undo") {
      alert("Example: undo pressed");
      setSelectedAssetId(null);
    } else if (actionType === "approve") {
      setSelectedObj(selectedGroup);
      setShowApproveModal(true);
    } else if (actionType === "delete") {
      setSelectedObj(selectedGroup);
      setShowDeleteModal(true);
    } else if (actionType === "reject") {
      setSelectedObj(selectedGroup);
      setShowRejectModal(true);
    }
  };

  // handleModalSubmit => when user confirms 
  const handleModalSubmit = () => {
    const { type, assetId } = showModal;
    if (type === "delete") {
      // remove from groupsState
      setGroupsState((prev) => prev.filter((g) => g.groupId !== assetId));
      setSelectedAssetId(null);
      updateAssembly();
    }
    setShowModal({ type: "", assetId: null });
    setModalInput({ reason: "", details: "", recommendations: "" });
  };

  const handleModalClose = () => {
    setShowModal({ type: "", assetId: null });
    setModalInput({ reason: "", details: "", recommendations: "" });
  };

  const handleAssemblyChange = (e) => {
    setSelectedAssembly(e.target.value);
  };

  // [CHANGED] “renderMockupSections” uses desktop images for BOTH tabs
  // but we differentiate screen sizes if user toggles the tab
  const renderMockupSections = (assemblies) => {
    const isMobile = activeTab === "mobile";
    return (
      <div>
        {assemblies.map((assemblyLabel) => {
          const maxItemsPerRow = parseInt(assemblyLabel, 10);
          let groupChunks = chunkArray(groupsState, maxItemsPerRow);

          if (isMobile && innerCollapsed && groupChunks.length > 2) {
            groupChunks = groupChunks.slice(0, 2);
          }

          // For desktop, we’ll do ["1280", "Inh"] 
          // For mobile, we’ll do ["375"] (or "375", "Inh" if you like).
          const screenLabels =
            activeTab === "desktop" ? ["1280", "Inh"] : ["375"];

          return (
            <div className="hubspokep-banner-container" key={assemblyLabel}>
              <div style={{ display: "flex" }}>
                <div className="hubspokep-assembly-label">
                  {`${assemblyLabel}-ROW ASSEMBLY`}
                </div>
                <div style={{ flex: 1 }}>
                  <div style={{ display: "flex", gap: "20px", overflowX: "auto" }}>
                    {screenLabels.map((screenSize, index) => {
                      const labelText = `${screenSize} (${
                        isMobile ? "M" : "D"
                      })`;
                      return (
                        <div key={`${assemblyLabel}-${screenSize}`}>
                          <div
                            className="hubspokep-banner-label"
                            style={{
                              backgroundColor:
                                index === 0
                                  ? "rgb(0, 57, 110)"
                                  : "rgb(172, 173, 176)",
                              color:
                                index === 0
                                  ? "rgb(255, 255, 255)"
                                  : "rgb(81, 83, 87)",
                            }}
                          >
                            {labelText}
                          </div>
                          <div
                            className="hubspokep-banner"
                            style={{ backgroundColor: metadata.bannerColor }}
                          >
                            <div className="hubspokep-page-name">
                              <h3>{metadata.pageName}</h3>
                            </div>
                            <div
                              className="hubspokep-banner-grid"
                              style={{
                                display: "grid",
                                gridTemplateColumns: `repeat(${maxItemsPerRow}, 1fr)`,
                                gap: "10px",
                              }}
                            >
                              {groupChunks.map((chunk, chunkIndex) => (
                                <React.Fragment key={`chunk-${chunkIndex}`}>
                                  {chunk.map((group) => {
                                    const selected = group.allAssets.find(
                                      (a) => a.id === group.selectedAssetId
                                    );
                                    const finalAsset =
                                      selected || group.allAssets[0];

                                    const cellSize = getImageSize(
                                      assemblyLabel,
                                      screenSize
                                    );

                                    return (
                                      <div
                                        key={`${assemblyLabel}-${screenSize}-${group.groupId}`}
                                        style={{
                                          display: "flex",
                                          flexDirection: "column",
                                          alignItems: "center",
                                          width: `${cellSize}px`,
                                        }}
                                      >
                                        <div
                                          style={{
                                            backgroundColor: "#EEE",
                                            borderRadius: "8px",
                                            display: "flex",
                                            justifyContent: "center",
                                            alignItems: "center",
                                            width: `${cellSize}px`,
                                            height: `${cellSize}px`,
                                            marginBottom: "5px",
                                          }}
                                        >
                                          {/* The same finalAsset.image regardless of tab */}
                                          <img
                                            src={finalAsset?.image}
                                            alt={finalAsset?.altText}
                                            style={{
                                              width: "100%",
                                              height: "100%",
                                              objectFit: "contain",
                                            }}
                                          />
                                        </div>
                                        <div
                                          style={{
                                            fontSize: "12px",
                                            textAlign: "center",
                                            whiteSpace: "normal",
                                          }}
                                        >
                                          {finalAsset?.altText}
                                        </div>
                                      </div>
                                    );
                                  })}
                                </React.Fragment>
                              ))}
                            </div>
                            {isMobile && chunkArray(groupsState, maxItemsPerRow).length >
                              2 && (
                              <button
                                onClick={() => setInnerCollapsed((prev) => !prev)}
                                style={{
                                  width: "100%",
                                  borderRadius: "500px",
                                  cursor: "pointer",
                                  backgroundColor: "transparent",
                                  border: "solid black 1px",
                                  marginTop: "4px",
                                  fontSize: "1rem",
                                  height: "32px",
                                }}
                              >
                                {innerCollapsed ? "See More" : "See Less"}
                              </button>
                            )}
                          </div>
                        </div>
                      );
                    })}
                  </div>
                </div>
              </div>
            </div>
          );
        })}
      </div>
    );
  };

  function handleContainerClick() {
    setSelectedAssetId(null);
  }

  // Decide action buttons
  let actionButtons = null;
  if (selectedAssetId) {
    actionButtons = (
      <>
        <button onClick={() => handleAction("approve")}>Approve</button>
        <button onClick={() => handleAction("reject")}>Reject</button>
        <button onClick={() => handleAction("delete")}>Delete</button>
      </>
    );
  }

  // -------------------------------------------------------------------
  // 5) Final return
  // -------------------------------------------------------------------
  return (
    <div className="hubspokep-container" onClick={handleContainerClick}>
      <div className="hubspokep-top-section" onClick={(e) => e.stopPropagation()}>
        {/* Meta Details */}
        <div className="hubspokep-meta-details">
          <div className="hubspokep-meta-details-content">
            <h3>Meta Details</h3>
            <p>
              <strong>Page Name:</strong> {metadata.pageName}
            </p>
            <p>
              <strong>Creator:</strong> {metadata.creator}
            </p>
            <p>
              <strong>Creation Date:</strong> {metadata.creationDate}
            </p>
            <p>
              <strong>Status:</strong> {metadata.status}
            </p>
            <p>
              <strong>Device Type:</strong> {metadata.deviceType}
            </p>
          </div>

          {/* [ADDED] "Add New Item" with JSON input */}
          <div className="hubspokep-add-item">
            <h4>Add New Item by JSON</h4>
            <textarea
              placeholder='Paste something like: {"groups":[{groupId:"...",assets:[...]},...]}'
              value={newGroupsJson}
              onChange={(e) => setNewGroupsJson(e.target.value)}
              rows={5}
              style={{ width: "100%", marginBottom: "8px" }}
            />
            <button onClick={handleAddNewItem}>Add Groups from JSON</button>
          </div>
        </div>

        {/* Groups/Assets Section */}
        <div className="hubspokep-assets-section">
          <div className="hubspokep-assets-header">
            <h3>Assets (Groups)</h3>
            <div style={{ display: "inline-block" }}>{actionButtons}</div>
          </div>
          <div
            className="hubspokep-assets-grid"
            onClick={(e) => e.stopPropagation()}
            style={{ display: "flex", flexWrap: "wrap" }}
          >
            {groupsState.map((group) => (
              <SortableItem
                key={group.groupId}
                group={group}
                onDragStart={handleDragStart}
                onDragOver={handleDragOver}
                onDrop={handleDrop}
                onSelectGroup={handleSelectAsset}
                isSelected={selectedAssetId === group.groupId}
                onModelLabelChange={handleModelLabelChange}
              />
            ))}
          </div>
        </div>

        {/* Tabs [CHANGED] We keep the toggle, but both tabs show the same finalAsset.image */}
        <div className="hubspokep-tabs" onClick={(e) => e.stopPropagation()}>
          <button
            onClick={() => {
              setActiveTab("desktop");
              setMetadata((prev) => ({ ...prev, deviceType: "Desktop" }));
            }}
            className={activeTab === "desktop" ? "active" : ""}
            aria-label="Switch to Desktop Tab"
          >
            Desktop
          </button>
          <button
            onClick={() => {
              setActiveTab("mobile");
              setMetadata((prev) => ({ ...prev, deviceType: "Mobile" }));
            }}
            className={activeTab === "mobile" ? "active" : ""}
            aria-label="Switch to Mobile Tab"
          >
            Mobile
          </button>
        </div>

        {/* Assembly Selection */}
        <div
          className="hubspokep-assembly-selection"
          onClick={(e) => e.stopPropagation()}
        >
          <label>Choose Assembly:</label>
          <select value={selectedAssembly} onChange={handleAssemblyChange}>
            {activeTab === "desktop"
              ? desktopYLabels.map((label) => (
                  <option key={label} value={label}>
                    {label}-row Assembly
                  </option>
                ))
              : mobileYLabels.map((label) => (
                  <option key={label} value={label}>
                    {label}-row Assembly
                  </option>
                ))}
          </select>
        </div>

        {/* Render the preview */}
        {renderMockupSections([selectedAssembly])}

        {/* Save Button */}
        <div className="hubspokep-save-button-container">
          <button
            className="hubspokep-save-button"
            onClick={() => {
              console.log("Final gridOutline:", gridOutline);
              alert("Saved!");
            }}
          >
            Save
          </button>
        </div>

        {/* Approve/Reject/Delete Modals (placeholder) */}
        {showApproveModal && <div>Approve Modal placeholder</div>}
        {showRejectModal && <div>Reject Modal placeholder</div>}
        {showDeleteModal && <div>Delete Modal placeholder</div>}
      </div>
    </div>
  );
};

export default HubspokePreview;


import React from "react";

export const SortableItem = ({
  group,
  onDragStart,
  onDragOver,
  onDrop,
  onSelectGroup,
  isSelected,
  onModelLabelChange,
}) => {
  // The currently selected asset
  const selectedAsset =
    group.allAssets.find((a) => a.id === group.selectedAssetId) ||
    group.allAssets[0];

  // The user can pick which modelLabel to show
  const modelLabels = group.allAssets.map((a) => a.modelLabel);

  const handleChange = (e) => {
    onModelLabelChange(group.groupId, e.target.value);
  };

  return (
    <div
      className={`sortable-item ${isSelected ? "selected" : ""}`}
      draggable
      onDragStart={(e) => onDragStart(e, group.groupId)}
      onDragOver={onDragOver}
      onDrop={(e) => onDrop(e, group.groupId)}
      onClick={(e) => {
        e.stopPropagation();
        onSelectGroup(group.groupId);
      }}
      style={{
        border: isSelected ? "2px solid #0073e6" : "1px solid #ccc",
        borderRadius: "4px",
        padding: "10px",
        margin: "5px",
        cursor: "grab",
        width: "160px",
        textAlign: "center",
      }}
    >
      <div style={{ marginBottom: "8px", fontWeight: "bold" }}>
        Group: {group.groupId}
      </div>
      <div style={{ marginBottom: "8px" }}>
        <img
          alt={selectedAsset?.altText}
          src={selectedAsset?.image}
          style={{ width: "100%", height: "80px", objectFit: "contain" }}
        />
      </div>
      <div>
        <select
          value={selectedAsset?.modelLabel}
          onChange={handleChange}
          style={{ width: "100%", padding: "4px", borderRadius: "4px" }}
        >
          {modelLabels.map((label) => (
            <option key={label} value={label}>
              {label}
            </option>
          ))}
        </select>
      </div>
    </div>
  );
};



//changes 2

import React, { useState, useEffect } from "react";
import { SortableItem } from "./sortableitem"; // Your child component

// We keep these arrays for row assemblies
const desktopYLabels = ["4", "6"];
const mobileYLabels = ["2", "3"];
const smartCreativeUsecase = "hubspoke";

// [Unchanged] - This is your base JSON for initial load
const abc = {
  reqId: "Test-0a56ac1c-353c-42b7-a3db-d212edd70e11",
  pageOffset: 0,
  modules: [
    {
      zone: null,
      moduleType: null,
      moduleId: null,
      configs: null,
      moduleResponse: [
        {
          gridId: "dd4c7927-60d4-4377-a582-de87fdeeee",
          status: "pending",
          gridName: "Test 1",
          pageName: "Fashion",
          pageId: "5438",
          updatedts: 1718057641528,
          createdts: 1718057641528,
          usecase: "hubspoke-grid",
          clientInfo: {
            requestBy: "aOsOcI8",
            channel: "Apollo Smart Creative",
          },
          gridOutline: [
            {
              position: 0,
              usecase: "hubspoke-pill",
              groupId: "test-req-sc-hubspoke-7",
              assetId: "de0d50a3-db1a-4654-b32e-123d57670£65",
            },
            {
              position: 1,
              usecase: "hubspoke-pill",
              groupId: "test-req-sc-hubspoke-5",
              assetId: "6c722£13-8d48-45d-b361-39bfb6223eb2",
            },
          ],
          groups: [
            {
              groupId: "test-reg-sc-hubspoke-7",
              status: "generated",
              updatedts: 1734957219756,
              createdts: 1734957219756,
              creativeAltText: {
                content: "Image shows Dyson Supersonic™ Hair Dryer | Fuchsia",
                creativeAiGenerated: false,
                generationInProgress: true,
              },
              type: "creative",
              itemIds: ["5087483962"],
              usecase: "hubspoke-pill",
              clientInfo: {
                requestBy: "kOe042c",
                channel: "scPlugin",
                env: "stage",
              },
              assets: [
                {
                  id: "de0d50a3-db1a-4654-b32e-123d57670£65",
                  modelLabel: "tight",
                  altText: "Image shows Dyson Supersonic™ Hair Dryer | Fuchsia",
                  image: "http://app.stg0.pronto.platform.prod.walmart.com/",
                },
                {
                  id: "a8e253dd-eac5-4cbb-b8fa-07820933b0af",
                  modelLabel: "crop",
                  altText: "Image shows Dyson Supersonic™ Hair Dryer | Fuchsia",
                  image: "http://app.stg0.pronto.platform.prod.walmart.com/",
                },
              ],
            },
            {
              groupId: "test-req-sc-hubspoke-5",
              status: "generated",
              updatedts: 1734956012781,
              createdts: 1734956012781,
              creativeAltText: {
                content: "Image shows Dyson Supersonic™ Hair Dryer | Fuchsia",
                creativeAiGenerated: false,
                generationInProgress: true,
              },
              type: "creative",
              itemIds: ["5087483962"],
              usecase: "hubspoke-pill",
              clientInfo: {
                requestBy: "KOe042c",
                channel: "scPlugin",
                env: "stage",
              },
              assets: [
                {
                  id: "6c722£13-8d48-45fd-b361-39bfb6223eb21",
                  modelLabel: "crop",
                  altText:
                    "Image shows Dyson Supersonic™ Hair Dryer | Fuchsia/Nickel | Refurbished",
                  image: "http://app.stg0.pronto.platform.prod.walmart.com/",
                },
                {
                  id: "bce9befc-c99e-4£71-9150-a6912b3f1a9d",
                  modelLabel: "tight",
                  altText: "Image shows Dyson Supersonic™ Hair Dryer | Fuchsia",
                  image: "http://app.stg0.pronto.platform.prod.walmart.com/",
                },
              ],
            },
          ],
        },
      ],
    },
  ],
  subType: null,
  errorDetails: [],
  features: null,
  styles: null,
};

const HubspokePreview = () => {
  // -------------------------------------------------------------------
  // 1) All top-level state
  // -------------------------------------------------------------------
  const [heading, setHeading] = useState(undefined);
  const [subheading, setSubHeading] = useState(undefined);
  const [showApproveModal, setShowApproveModal] = useState(false);
  const [requestProcessing, setRequestProcessing] = useState(false);
  const [reason, setReason] = useState(undefined);
  const [selectedObj, setSelectedObj] = useState(undefined);
  const [recommendation, setRecommendation] = useState(undefined);
  const [comments, setComments] = useState(undefined);
  const [reasonSelected, setReasonSelected] = useState(undefined);
  const [showRejectModal, setShowRejectModal] = useState(false);
  const [showDeleteModal, setShowDeleteModal] = useState(false);

  // We keep a toggle for desktop vs mobile:
  const [activeTab, setActiveTab] = useState("desktop");

  // [CHANGED] groupsState: each group has "groupId, allAssets, selectedAssetId"
  const [groupsState, setGroupsState] = useState([]);

  // If a user clicks a group, we store that group's ID here
  const [selectedAssetId, setSelectedAssetId] = useState(null);

  // For row assembly (4 or 6 in desktop, 2 or 3 in mobile):
  const [selectedAssembly, setSelectedAssembly] = useState("4");
  const [innerCollapsed, setInnerCollapsed] = useState(true);
  const [modalInput, setModalInput] = useState({
    reason: "",
    details: "",
    recommendations: "",
  });
  const [showModal, setShowModal] = useState({ type: "", assetId: null });
  const [draggedItemId, setDraggedItemId] = useState(null);

  // Data loading states
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // Basic metadata for the page
  const [metadata, setMetadata] = useState({
    pageName: "",
    bannerColor: "#FFFFFF",
    creator: "",
    creationDate: "",
    status: "",
    deviceType: "Desktop",
  });

  // We keep the outline from the original JSON so we can update asset IDs
  const [gridOutline, setGridOutline] = useState([]);

  // -------------------------------------------------------------------
  // 2) Hooks in stable order
  // -------------------------------------------------------------------
  useEffect(() => {
    // Simulate fetching the base "abc" JSON:
    try {
      setData(abc);
      setLoading(false);
    } catch (err) {
      setError(err);
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    if (!data) return;
    const moduleResponse = data.modules?.[0]?.moduleResponse?.[0];
    if (!moduleResponse) return;

    // store the existing outline
    setGridOutline(moduleResponse.gridOutline || []);

    // parse metadata
    const { pageName, status, clientInfo, createdts, groups } = moduleResponse;
    const creationDateStr = createdts
      ? new Date(createdts).toLocaleString()
      : new Date().toLocaleString();

    setMetadata((prev) => ({
      ...prev,
      pageName: pageName || "Untitled Page",
      creator: clientInfo?.requestBy || "Unknown",
      creationDate: creationDateStr,
      status: status || "Draft",
    }));

    // build groupsState from the JSON
    if (groups && Array.isArray(groups)) {
      const newGroups = groups.map((g) => {
        // find the existing outline entry for this group
        const outlineItem = moduleResponse.gridOutline.find(
          (o) => o.groupId === g.groupId
        );
        // if none found, pick the first asset as default
        const selectedAssetId = outlineItem?.assetId || g.assets?.[0]?.id;

        return {
          groupId: g.groupId,
          allAssets: g.assets || [],
          selectedAssetId,
        };
      });
      setGroupsState(newGroups);
    }
  }, [data]);

  // if groupsState or tab changes, update assembly selection
  useEffect(() => {
    updateAssembly();
  }, [activeTab, groupsState]);

  // if mobile, decide whether to collapse
  useEffect(() => {
    if (activeTab === "mobile") {
      const maxItemsPerRow = parseInt(selectedAssembly, 10);
      const groupChunks = chunkArray(groupsState, maxItemsPerRow);
      setInnerCollapsed(groupChunks.length > 2);
    } else {
      setInnerCollapsed(false);
    }
  }, [activeTab, selectedAssembly, groupsState]);

  // -------------------------------------------------------------------
  // 3) Early returns if loading or error
  // -------------------------------------------------------------------
  if (loading) return <div>Loading data...</div>;
  if (error) return <div>Error loading data: {error.message}</div>;
  if (!data) return <div>No data available</div>;

  // get moduleResponse
  const moduleResponse = data.modules?.[0]?.moduleResponse?.[0];
  if (!moduleResponse) {
    return <div>No moduleResponse found in data</div>;
  }

  // -------------------------------------------------------------------
  // 4) Helper Functions
  // -------------------------------------------------------------------
  function updateAssembly() {
    const count = groupsState.length;
    if (activeTab === "desktop") {
      setSelectedAssembly(count > 4 ? "6" : "4");
    } else {
      setSelectedAssembly(count <= 4 ? "2" : "3");
    }
  }

  function chunkArray(array, size) {
    const result = [];
    for (let i = 0; i < array.length; i += size) {
      result.push(array.slice(i, i + size));
    }
    return result;
  }

  // handleBehaviorChange => picking new modelLabel
  const handleModelLabelChange = (groupId, newModelLabel) => {
    setGroupsState((prev) =>
      prev.map((g) => {
        if (g.groupId === groupId) {
          // find the asset with that modelLabel
          const foundAsset = g.allAssets.find(
            (a) => a.modelLabel === newModelLabel
          );
          if (foundAsset) {
            // update the gridOutline so assetId matches foundAsset.id
            setGridOutline((prevOutline) =>
              prevOutline.map((o) => {
                if (o.groupId === groupId) {
                  return { ...o, assetId: foundAsset.id };
                }
                return o;
              })
            );
            return { ...g, selectedAssetId: foundAsset.id };
          }
        }
        return g;
      })
    );
  };

  function getImageSize(assemblyLabel, screenSize) {
    const maxItemsPerRow = parseInt(assemblyLabel, 10);
    const isDesktop = activeTab === "desktop";

    if (isDesktop) {
      if (screenSize === "1280") {
        if (maxItemsPerRow === 4) return 290;
        if (maxItemsPerRow === 6) return 192;
      } else if (screenSize === "Inh") {
        if (maxItemsPerRow === 4) return 200;
        if (maxItemsPerRow === 6) return 132;
      }
    } else {
      // mobile
      if (screenSize === "375") {
        if (maxItemsPerRow === 2) return 135;
        if (maxItemsPerRow === 3) return 104;
      }
    }
    return 100;
  }

  // [NEW / CHANGED] handleSave to create a new JSON based on groupsState
  const handleSave = () => {
    // 1) Rebuild an updated gridOutline
    //    Each group's new position is its index in groupsState
    const updatedGridOutline = groupsState.map((g, index) => ({
      position: index,
      usecase: "hubspoke-pill", // or whatever
      groupId: g.groupId,
      assetId: g.selectedAssetId,
    }));

    // 2) Rebuild a "groups" array in the new order
    //    This can preserve other fields (status, creativeAltText, etc.) if needed,
    //    but here we just keep assets, groupId, plus some placeholders
    const updatedGroups = groupsState.map((g) => {
      return {
        groupId: g.groupId,
        status: "generated", // placeholder
        updatedts: Date.now(),
        createdts: Date.now(),
        assets: g.allAssets,
      };
    });

    // 3) Construct a new moduleResponse with the updated outline, groups, etc.
    //    We keep other fields from moduleResponse
    const newModuleResponse = {
      ...moduleResponse,
      gridOutline: updatedGridOutline,
      groups: updatedGroups,
    };

    // 4) Rebuild the top-level data object
    const newData = {
      ...data,
      modules: [
        {
          ...data.modules[0],
          moduleResponse: [newModuleResponse],
        },
      ],
    };

    // For demonstration, we just log it out
    console.log("Newly saved JSON:", JSON.stringify(newData, null, 2));
    alert("New JSON has been logged to console!");
  };

  // Drag & drop logic
  const handleDragStart = (e, groupId) => {
    setDraggedItemId(groupId);
    e.dataTransfer.effectAllowed = "move";
  };
  const handleDragOver = (e) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = "move";
  };
  const handleDrop = (e, groupId) => {
    e.preventDefault();
    const draggedIndex = groupsState.findIndex((g) => g.groupId === draggedItemId);
    const dropIndex = groupsState.findIndex((g) => g.groupId === groupId);
    if (draggedIndex !== dropIndex) {
      const updated = [...groupsState];
      const [draggedGroup] = updated.splice(draggedIndex, 1);
      updated.splice(dropIndex, 0, draggedGroup);
      setGroupsState(updated);
    }
    setDraggedItemId(null);
  };

  const handleSelectAsset = (groupId) => {
    setSelectedAssetId(groupId === selectedAssetId ? null : groupId);
  };

  // Action logic placeholders
  const handleAction = (actionType) => {
    if (!selectedAssetId) {
      alert("No group selected.");
      return;
    }
    const selectedGroup = groupsState.find((g) => g.groupId === selectedAssetId);
    if (!selectedGroup) return;

    if (actionType === "undo") {
      alert("Example: undo pressed");
      setSelectedAssetId(null);
    } else if (actionType === "approve") {
      setSelectedObj(selectedGroup);
      setShowApproveModal(true);
    } else if (actionType === "delete") {
      setSelectedObj(selectedGroup);
      setShowDeleteModal(true);
    } else if (actionType === "reject") {
      setSelectedObj(selectedGroup);
      setShowRejectModal(true);
    }
  };

  // [CHANGED] If user confirms "delete," remove from groupsState
  const handleModalSubmit = () => {
    const { type, assetId } = showModal;
    if (type === "delete") {
      setGroupsState((prev) => prev.filter((g) => g.groupId !== assetId));
      setSelectedAssetId(null);
      updateAssembly();
    }
    setShowModal({ type: "", assetId: null });
    setModalInput({ reason: "", details: "", recommendations: "" });
  };

  const handleModalClose = () => {
    setShowModal({ type: "", assetId: null });
    setModalInput({ reason: "", details: "", recommendations: "" });
  };

  const handleAssemblyChange = (e) => {
    setSelectedAssembly(e.target.value);
  };

  // Renders the big preview area for the selected assembly (row count)
  const renderMockupSections = (assemblies) => {
    const isMobile = activeTab === "mobile";
    return (
      <div>
        {assemblies.map((assemblyLabel) => {
          const maxItemsPerRow = parseInt(assemblyLabel, 10);
          let groupChunks = chunkArray(groupsState, maxItemsPerRow);

          if (isMobile && innerCollapsed && groupChunks.length > 2) {
            groupChunks = groupChunks.slice(0, 2);
          }

          const screenLabels =
            activeTab === "desktop" ? ["1280", "Inh"] : ["375"];

          return (
            <div className="hubspokep-banner-container" key={assemblyLabel}>
              <div style={{ display: "flex" }}>
                <div className="hubspokep-assembly-label">
                  {`${assemblyLabel}-ROW ASSEMBLY`}
                </div>
                <div style={{ flex: 1 }}>
                  <div style={{ display: "flex", gap: "20px", overflowX: "auto" }}>
                    {screenLabels.map((screenSize, index) => {
                      const labelText = `${screenSize} (${
                        isMobile ? "M" : "D"
                      })`;
                      return (
                        <div key={`${assemblyLabel}-${screenSize}`}>
                          <div
                            className="hubspokep-banner-label"
                            style={{
                              backgroundColor:
                                index === 0
                                  ? "rgb(0, 57, 110)"
                                  : "rgb(172, 173, 176)",
                              color:
                                index === 0
                                  ? "rgb(255, 255, 255)"
                                  : "rgb(81, 83, 87)",
                            }}
                          >
                            {labelText}
                          </div>
                          <div
                            className="hubspokep-banner"
                            style={{ backgroundColor: metadata.bannerColor }}
                          >
                            <div className="hubspokep-page-name">
                              <h3>{metadata.pageName}</h3>
                            </div>
                            <div
                              className="hubspokep-banner-grid"
                              style={{
                                display: "grid",
                                gridTemplateColumns: `repeat(${maxItemsPerRow}, 1fr)`,
                                gap: "10px",
                              }}
                            >
                              {groupChunks.map((chunk, chunkIndex) => (
                                <React.Fragment key={`chunk-${chunkIndex}`}>
                                  {chunk.map((group) => {
                                    // find the selected asset for this group
                                    const selected = group.allAssets.find(
                                      (a) => a.id === group.selectedAssetId
                                    );
                                    const finalAsset =
                                      selected || group.allAssets[0];

                                    const cellSize = getImageSize(
                                      assemblyLabel,
                                      screenSize
                                    );

                                    return (
                                      <div
                                        key={`${assemblyLabel}-${screenSize}-${group.groupId}`}
                                        style={{
                                          display: "flex",
                                          flexDirection: "column",
                                          alignItems: "center",
                                          width: `${cellSize}px`,
                                        }}
                                      >
                                        <div
                                          style={{
                                            backgroundColor: "#EEE",
                                            borderRadius: "8px",
                                            display: "flex",
                                            justifyContent: "center",
                                            alignItems: "center",
                                            width: `${cellSize}px`,
                                            height: `${cellSize}px`,
                                            marginBottom: "5px",
                                          }}
                                        >
                                          <img
                                            src={finalAsset?.image}
                                            alt={finalAsset?.altText}
                                            style={{
                                              width: "100%",
                                              height: "100%",
                                              objectFit: "contain",
                                            }}
                                          />
                                        </div>
                                        <div
                                          style={{
                                            fontSize: "12px",
                                            textAlign: "center",
                                            whiteSpace: "normal",
                                          }}
                                        >
                                          {finalAsset?.altText}
                                        </div>
                                      </div>
                                    );
                                  })}
                                </React.Fragment>
                              ))}
                            </div>

                            {/* For mobile, if user wants to see more/less */}
                            {isMobile &&
                              chunkArray(groupsState, maxItemsPerRow).length >
                                2 && (
                                <button
                                  onClick={() => setInnerCollapsed((prev) => !prev)}
                                  style={{
                                    width: "100%",
                                    borderRadius: "500px",
                                    cursor: "pointer",
                                    backgroundColor: "transparent",
                                    border: "solid black 1px",
                                    marginTop: "4px",
                                    fontSize: "1rem",
                                    height: "32px",
                                  }}
                                >
                                  {innerCollapsed ? "See More" : "See Less"}
                                </button>
                              )}
                          </div>
                        </div>
                      );
                    })}
                  </div>
                </div>
              </div>
            </div>
          );
        })}
      </div>
    );
  };

  // click outside a group => deselect
  const handleContainerClick = () => {
    setSelectedAssetId(null);
  };

  // Show relevant action buttons if a group is selected
  let actionButtons = null;
  if (selectedAssetId) {
    actionButtons = (
      <>
        <button onClick={() => handleAction("approve")}>Approve</button>
        <button onClick={() => handleAction("reject")}>Reject</button>
        <button onClick={() => handleAction("delete")}>Delete</button>
      </>
    );
  }

  // -------------------------------------------------------------------
  // 5) Final return
  // -------------------------------------------------------------------
  return (
    <div className="hubspokep-container" onClick={handleContainerClick}>
      <div
        className="hubspokep-top-section"
        onClick={(e) => e.stopPropagation()}
      >
        {/* Meta Details */}
        <div className="hubspokep-meta-details">
          <div className="hubspokep-meta-details-content">
            <h3>Meta Details</h3>
            <p>
              <strong>Page Name:</strong> {metadata.pageName}
            </p>
            <p>
              <strong>Creator:</strong> {metadata.creator}
            </p>
            <p>
              <strong>Creation Date:</strong> {metadata.creationDate}
            </p>
            <p>
              <strong>Status:</strong> {metadata.status}
            </p>
            <p>
              <strong>Device Type:</strong> {metadata.deviceType}
            </p>
          </div>

          {/* [Placeholder for adding new item JSON, if needed] */}
        </div>

        {/* Groups/Assets Section */}
        <div className="hubspokep-assets-section">
          <div className="hubspokep-assets-header">
            <h3>Assets (Groups)</h3>
            <div style={{ display: "inline-block" }}>{actionButtons}</div>
          </div>
          <div
            className="hubspokep-assets-grid"
            onClick={(e) => e.stopPropagation()}
            style={{ display: "flex", flexWrap: "wrap" }}
          >
            {groupsState.map((group) => (
              <SortableItem
                key={group.groupId}
                group={group}
                onDragStart={handleDragStart}
                onDragOver={handleDragOver}
                onDrop={handleDrop}
                onSelectGroup={handleSelectAsset}
                isSelected={selectedAssetId === group.groupId}
                onModelLabelChange={handleModelLabelChange}
              />
            ))}
          </div>
        </div>

        {/* Tab Buttons (Desktop/Mobile) */}
        <div className="hubspokep-tabs" onClick={(e) => e.stopPropagation()}>
          <button
            onClick={() => {
              setActiveTab("desktop");
              setMetadata((prev) => ({ ...prev, deviceType: "Desktop" }));
            }}
            className={activeTab === "desktop" ? "active" : ""}
            aria-label="Switch to Desktop Tab"
          >
            Desktop
          </button>
          <button
            onClick={() => {
              setActiveTab("mobile");
              setMetadata((prev) => ({ ...prev, deviceType: "Mobile" }));
            }}
            className={activeTab === "mobile" ? "active" : ""}
            aria-label="Switch to Mobile Tab"
          >
            Mobile
          </button>
        </div>

        {/* Assembly Selection */}
        <div
          className="hubspokep-assembly-selection"
          onClick={(e) => e.stopPropagation()}
        >
          <label>Choose Assembly:</label>
          <select value={selectedAssembly} onChange={handleAssemblyChange}>
            {activeTab === "desktop"
              ? desktopYLabels.map((label) => (
                  <option key={label} value={label}>
                    {label}-row Assembly
                  </option>
                ))
              : mobileYLabels.map((label) => (
                  <option key={label} value={label}>
                    {label}-row Assembly
                  </option>
                ))}
          </select>
        </div>

        {/* Render the banner preview */}
        {renderMockupSections([selectedAssembly])}

        {/* [CHANGED / NEW] Save Button => calls handleSave to build new JSON */}
        <div className="hubspokep-save-button-container">
          <button className="hubspokep-save-button" onClick={handleSave}>
            Save
          </button>
        </div>

        {/* Approve/Reject/Delete placeholders */}
        {showApproveModal && <div>Approve Modal placeholder</div>}
        {showRejectModal && <div>Reject Modal placeholder</div>}
        {showDeleteModal && <div>Delete Modal placeholder</div>}
      </div>
    </div>
  );
};

export default HubspokePreview;


import React from "react";

export const SortableItem = ({
  group,
  onDragStart,
  onDragOver,
  onDrop,
  onSelectGroup,
  isSelected,
  onModelLabelChange,
}) => {
  // The currently selected asset in this group
  const selectedAsset =
    group.allAssets.find((a) => a.id === group.selectedAssetId) ||
    group.allAssets[0];

  // The user can pick which modelLabel to show
  const modelLabels = group.allAssets.map((a) => a.modelLabel);

  const handleChange = (e) => {
    onModelLabelChange(group.groupId, e.target.value);
  };

  return (
    <div
      className={`sortable-item ${isSelected ? "selected" : ""}`}
      draggable
      onDragStart={(e) => onDragStart(e, group.groupId)}
      onDragOver={onDragOver}
      onDrop={(e) => onDrop(e, group.groupId)}
      onClick={(e) => {
        // Prevent parent from deselecting if we click inside
        e.stopPropagation();
        onSelectGroup(group.groupId);
      }}
      style={{
        border: isSelected ? "2px solid #0073e6" : "1px solid #ccc",
        borderRadius: "4px",
        padding: "10px",
        margin: "5px",
        cursor: "grab",
        width: "160px",
        textAlign: "center",
      }}
    >
      <div style={{ marginBottom: "8px", fontWeight: "bold" }}>
        Group: {group.groupId}
      </div>
      <div style={{ marginBottom: "8px" }}>
        <img
          alt={selectedAsset?.altText}
          src={selectedAsset?.image}
          style={{ width: "100%", height: "80px", objectFit: "contain" }}
        />
      </div>
      <div>
        <select
          value={selectedAsset?.modelLabel}
          onChange={handleChange}
          style={{ width: "100%", padding: "4px", borderRadius: "4px" }}
        >
          {modelLabels.map((label) => (
            <option key={label} value={label}>
              {label}
            </option>
          ))}
        </select>
      </div>
    </div>
  );
};
