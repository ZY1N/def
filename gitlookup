Logo
Home
Dojos
Achievements
Profile
Pricing
Sign in
dojo
Git Cheatsheet
Start learning for free
ShortcutFoo uses a Spaced Repetition System that adapts to your training.
scf keyboard
Git Basics
git init
Initialize a repository
git status
Show status of working tree
git add file.txt
Start tracking file.txt
git add main.txt
Stage modified file main.txt
git diff
Show what's changed but not yet staged
git commit
Commit changes
git commit -a
Stage files and commit
git mv main.txt file.txt
Rename main.txt to file.txt
git fetch develop
Pull data from remote 'develop' without merging
git pull origin develop
Fetch and merge branch 'develop' from origin
git clone url
Create local copy of remote repository at 'url'
scf keyboard
Branching
git branch
Show current branches
git push origin master
Push master branch to origin server
git branch -v
Show last commit on all branches
git checkout master
Switch to branch 'master'
git branch feature1
Create new branch called 'feature1'
git checkout -b feature2
Create branch 'feature2' and switch to it
git branch -d mybranch
Delete branch 'mybranch'
git branch --merged
Show branches already merged into current branch
git branch --no-merged
Show branches not yet merged into current branch
git branch -D fix
Force delete branch 'fix' that is not yet merged
git push origin feature1
Push local branch 'feature1' to origin
git push staging develop:master
Push develop branch to remote staging master
git checkout -b fix1 origin/fix1
Create local branch 'fix1' based off origin branch
git checkout --track origin/fix2
Create tracking branch 'fix2' based off origin
git push origin :fix2
Delete remote branch 'fix2' from origin
scf keyboard
Merging / Rebasing
git mergetool
Use graphical merge tool
git commit
Finalize merge after resolving conflicts
git merge feature1
Merge branch 'feature1' with current branch
git add file.txt
Mark file.txt as resolved after merge
git rebase develop
Rebase changes made on current branch over develop
git rebase master develop
Rebase master onto develop without checking it out
git rebase --onto master 1a 1b
Rebase master onto branch 1b made from branch 1a
scf keyboard
Remotes
git remote
Show remote servers you have configured
git remote -v
Show remote servers with URL displayed
git remote add myurl url
Add remote server 'url' with shortname 'myurl'
git remote rename server1 server2
Rename remote 'server1' to 'server2'
git remote rm server1
Remove remote 'server1'
git remote show origin
Show info about remote origin
scf keyboard
Commit Logs
git log
Show commit logs
git log -p -2
Show last two commits with diffs
git log --stat
Show commit logs with stats
git log --pretty=oneline
Show commit logs one per line
git log --graph
Show commit logs with ascii graph
git log --since=1.week
Show commit log for the last week
git blame -L 10,15 file.rb
Show prev commits for each lines 10-15 of file.rb
scf keyboard
Undo / Change History
git rm --cached main.txt
Remove main.txt from staging but keep in working
git commit --amend
Replace last commit with whats in staging
git checkout -- file.txt
Discard changes to file.txt
git reset HEAD file.txt
Unstage file.txt
git commit --amend
Modify last commit message
git rebase -i HEAD`3
Make changes to the last 3 commits
scf keyboard
Using Tags
git tag
Show available tags
git tag -a v3.0
Create annotated tag 'v3.0'
git show v3.0
Show info for tag v3.0
git tag -s v3.0
Create signed tag v3.0
git tag v2.1-lw
Create lightweight tag v2.1
git tag -v v3.0
Verify signed tag v3.0
git tag -a v2.2 8feb
Tag previous commit '8feb' as v2.2
git push origin v2.2
Push tag v2.2 to origin
git push origin --tags
Push all local tags to origin
scf keyboard
Using Stashes
git stash
Stash changes without committing
git stash list
Show stores stashes
git stash apply
Reapply most recent stash
git stash apply stash@2
Reapply stash 2
git stash apply --index
Reapply stashed changes along with staged changes
git stash drop stash@{2}
Drop stash 2
git stash pop
Apply most recent stash and drop from stack
git stash branch mybranch
Create branch 'mybranch' from stash
git stash clear
Delete all stashes
git diff --staged
Show what's staged but not yet committed
git diff --check
Check for whitespace errors before committing
scf keyboard
Using Bisect
git bisect start
Start binary search of commits to find bad commit
git bisect bad
Mark current commit as broken during bisect
git bisect good v2.2
Mark v2.2 as last known good commit during bisect
git bisect good
Mark current commit as good during bisect
git bisect reset
Reset HEAD when finished with bisect
git bisect run test.sh
Run 'test.sh' on each commit during bisect
achievement-star
Blog
About
Privacy Policy
Terms of Service
Tournaments
Pricing
Facebook
Twitter
Â© 2025 ShortcutFoo, LLC. All rights reserved.



import React, { useState } from "react";

const ImageUploadFields = () => {
  // Dummy images that the user can drag from
  const dummyImages = [
    "https://via.placeholder.com/50",
    "https://via.placeholder.com/50/FF0000",
    "https://via.placeholder.com/50/00FF00",
  ];

  // Each field has: { id, images: [], hasUploaded: false }
  const [fields, setFields] = useState([
    { id: Date.now(), images: [], hasUploaded: false },
  ]);

  // Convert file to base64 using Promises
  const convertToBase64 = (file) => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.readAsDataURL(file);
      reader.onload = () => resolve(reader.result);
      reader.onerror = (err) => reject(err);
    });
  };

  // Handle dropping either from dummy store or local file(s)
  const handleDrop = (event, fieldId) => {
    event.preventDefault();

    // Check if user dragged an image from the dummy store
    const storeSrc = event.dataTransfer.getData("text/plain");
    if (storeSrc) {
      setFields((prev) =>
        prev.map((field) =>
          field.id === fieldId
            ? {
                ...field,
                images: [
                  ...field.images,
                  {
                    id: storeSrc,
                    name: "Dragged Image",
                    base64: storeSrc,
                  },
                ],
                hasUploaded: true,
              }
            : field
        )
      );
      return; // Done
    }

    // Otherwise, assume user dropped local file(s)
    const files = Array.from(event.dataTransfer.files);
    if (files.length === 0) return;

    Promise.all(
      files.map((file) =>
        convertToBase64(file).then((base64) => ({
          id: URL.createObjectURL(file),
          name: file.name,
          base64,
        }))
      )
    ).then((base64Files) => {
      setFields((prev) =>
        prev.map((field) =>
          field.id === fieldId
            ? {
                ...field,
                images: [...field.images, ...base64Files],
                hasUploaded: true,
              }
            : field
        )
      );
    });
  };

  // Handle selecting files with the file input
  const handleFileUpload = (event, fieldId) => {
    const files = Array.from(event.target.files);
    if (files.length === 0) return;

    Promise.all(
      files.map((file) =>
        convertToBase64(file).then((base64) => ({
          id: URL.createObjectURL(file),
          name: file.name,
          base64,
        }))
      )
    ).then((base64Files) => {
      setFields((prev) =>
        prev.map((field) =>
          field.id === fieldId
            ? {
                ...field,
                images: [...field.images, ...base64Files],
                hasUploaded: true,
              }
            : field
        )
      );
    });
  };

  // Remove an image from a particular field
  // If field has no images left after removal, remove that field
  const removeImage = (fieldId, imageId) => {
    setFields((prev) =>
      prev.reduce((acc, field) => {
        if (field.id === fieldId) {
          const updatedImages = field.images.filter(
            (img) => img.id !== imageId
          );
          // If no images left => remove the field
          if (updatedImages.length === 0) {
            return acc; // skip pushing this field
          }
          // Otherwise update with the new images array
          return [...acc, { ...field, images: updatedImages }];
        } else {
          return [...acc, field];
        }
      }, [])
    );
  };

  // Add a new (empty) field
  const addField = () => {
    setFields((prev) => [
      ...prev,
      { id: Date.now(), images: [], hasUploaded: false },
    ]);
  };

  // Check if the "Add More" button should be disabled
  // i.e. if the last field is empty (no images), disable it
  const lastField = fields[fields.length - 1];
  const disableAddMore = lastField && lastField.images.length === 0;

  return (
    <div>
      {fields.map((field) => (
        <div key={field.id} style={{ marginBottom: "1rem" }}>
          {/* 
            Show the entire DnD div only if there are NO images 
            => once the field is "filled," hide the DnD 
          */}
          {field.images.length === 0 && (
            <div
              onDrop={(event) => handleDrop(event, field.id)}
              onDragOver={(event) => event.preventDefault()}
              style={{
                width: "100%",
                height: "40px",
                border: "1px solid #ced4da",
                borderRadius: "5px",
                padding: "5px",
                display: "flex",
                alignItems: "center",
                justifyContent: "space-between",
                cursor: "pointer",
                backgroundColor: "#f8f9fa",
                position: "relative",
              }}
            >
              <span>Drag & Drop or Click to Upload</span>

              <input
                type="file"
                accept="image/*"
                multiple
                onChange={(e) => handleFileUpload(e, field.id)}
                style={{
                  position: "absolute",
                  opacity: 0,
                  width: "100%",
                  height: "100%",
                  cursor: "pointer",
                }}
              />
            </div>
          )}

          {/* Show label only if there are images in this field */}
          {field.images.length > 0 && (
            <div
              style={{
                fontWeight: "bold",
                marginTop: "10px",
                marginBottom: "5px",
              }}
            >
              Images Uploaded:
            </div>
          )}

          {/* Display images vertically */}
          {field.images.map((file) => (
            <div
              key={file.id}
              style={{
                display: "flex",
                alignItems: "center",
                marginBottom: "5px",
              }}
            >
              <img
                src={file.base64}
                alt={file.name}
                style={{
                  width: "50px",
                  height: "50px",
                  objectFit: "cover",
                  borderRadius: "5px",
                }}
              />

              <button
                onClick={() => removeImage(field.id, file.id)}
                style={{
                  background: "red",
                  color: "white",
                  border: "none",
                  borderRadius: "50%",
                  width: "20px",
                  height: "20px",
                  cursor: "pointer",
                  fontSize: "12px",
                  marginLeft: "5px",
                }}
              >
                X
              </button>
            </div>
          ))}
        </div>
      ))}

      {/* 
        Disable "Add More" if the last field is empty (no images).
        => Forces user to fill each field before adding another.
      */}
      <button
        onClick={addField}
        disabled={disableAddMore}
        style={{
          backgroundColor: disableAddMore ? "gray" : "green",
          color: "#fff",
          padding: "8px 12px",
          border: "none",
          borderRadius: "4px",
          cursor: disableAddMore ? "not-allowed" : "pointer",
        }}
      >
        Add More
      </button>

      {/* Dummy Store to drag images from */}
      <div
        style={{
          marginTop: "20px",
          borderTop: "2px solid #ddd",
          paddingTop: "10px",
        }}
      >
        <h4>Drag from Image Store:</h4>
        <div style={{ display: "flex", gap: "10px" }}>
          {dummyImages.map((src, idx) => (
            <img
              key={idx}
              src={src}
              alt={`dummy-${idx}`}
              draggable="true"
              onDragStart={(event) => {
                event.dataTransfer.setData("text/plain", src);
              }}
              style={{
                width: "50px",
                height: "50px",
                objectFit: "cover",
                borderRadius: "5px",
                cursor: "grab",
              }}
            />
          ))}
        </div>
      </div>
    </div>
  );
};

export default ImageUploadFields;
